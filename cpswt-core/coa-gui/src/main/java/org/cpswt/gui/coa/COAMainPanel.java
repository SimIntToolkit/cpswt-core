/*
 * Copyright (c) 2008, Institute for Software Integrated Systems, Vanderbilt University
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software and its
 * documentation for any purpose, without fee, and without written agreement is
 * hereby granted, provided that the above copyright notice, the following
 * two paragraphs and the author appear in all copies of this software.
 *
 * IN NO EVENT SHALL THE VANDERBILT UNIVERSITY BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF THE VANDERBILT
 * UNIVERSITY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE VANDERBILT UNIVERSITY SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE.  THE SOFTWARE PROVIDED HEREUNDER IS
 * ON AN "AS IS" BASIS, AND THE VANDERBILT UNIVERSITY HAS NO OBLIGATION TO
 * PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR MODIFICATIONS.
 * 
 * @author Himanshu Neema
 */

package org.cpswt.gui.coa;

import java.awt.Color;
import java.beans.PropertyChangeEvent;
import java.beans.PropertyChangeListener;
import java.util.HashMap;

import javax.swing.JLabel;

import org.cpswt.coa.COAEdge;
import org.cpswt.coa.COAGraph;
import org.cpswt.coa.COANode;

import com.mxgraph.layout.hierarchical.mxHierarchicalLayout;
import com.mxgraph.model.mxCell;
import com.mxgraph.swing.mxGraphComponent;
import com.mxgraph.util.mxConstants;
import com.mxgraph.view.mxGraph;

/**
 * Main Panel for the Federation Manager.
 * 
 * @author Himanshu Neema
 */
public class COAMainPanel extends javax.swing.JPanel implements
		PropertyChangeListener {

	private static final long serialVersionUID = 1L;
	
	private COAGraph _coaGraph = null;
	
	private mxGraph _graph = null;
	
	private mxGraphComponent _graphComponent = null;
	
	private Object _parent = null;
	
	private HashMap<mxCell, COANode> _cell2COANodeMap = new HashMap<mxCell, COANode>();
	
	private HashMap<COANode, mxCell> _coaNode2Cell = new HashMap<COANode, mxCell>();

	/** Creates new form COAMainPanel */
	public COAMainPanel(COAGraph coaGraph) {
		initComponents();
		init(coaGraph);
	}

	/**
	 * This method is called from within the constructor to initialize the form.
	 * WARNING: Do NOT modify this code. The content of this method is always
	 * regenerated by the Form Editor.
	 */
	// <editor-fold defaultstate="collapsed"
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {
        java.awt.GridBagConstraints gridBagConstraints;

        jScrollPane1 = new javax.swing.JScrollPane();
        legendLabel = new javax.swing.JLabel();
        inactivePanel = new javax.swing.JPanel();
        inactiveLabel = new javax.swing.JLabel();
        activePanel = new javax.swing.JPanel();
        activeLabel = new javax.swing.JLabel();
        executedPanel = new javax.swing.JPanel();
        executedLabel = new javax.swing.JLabel();

        setPreferredSize(new java.awt.Dimension(700, 400));
        setLayout(new java.awt.GridBagLayout());
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 0;
        gridBagConstraints.gridwidth = java.awt.GridBagConstraints.REMAINDER;
        gridBagConstraints.gridheight = java.awt.GridBagConstraints.RELATIVE;
        gridBagConstraints.fill = java.awt.GridBagConstraints.BOTH;
        gridBagConstraints.weightx = 1.0;
        gridBagConstraints.weighty = 1.0;
        add(jScrollPane1, gridBagConstraints);

        legendLabel.setText("Legend:");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 0;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LAST_LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(20, 10, 10, 10);
        add(legendLabel, gridBagConstraints);

        inactivePanel.setBackground(java.awt.Color.green);
        inactivePanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 1;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LAST_LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(20, 10, 10, 0);
        add(inactivePanel, gridBagConstraints);

        inactiveLabel.setText("INACTIVE");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 2;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LAST_LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(20, 5, 10, 5);
        add(inactiveLabel, gridBagConstraints);

        activePanel.setBackground(java.awt.Color.yellow);
        activePanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 3;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LAST_LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(20, 10, 10, 0);
        add(activePanel, gridBagConstraints);

        activeLabel.setText("ACTIVE (in progress)");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 4;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LAST_LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(20, 5, 10, 5);
        add(activeLabel, gridBagConstraints);

        executedPanel.setBackground(java.awt.Color.red);
        executedPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0)));
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 5;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LAST_LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(20, 10, 10, 0);
        add(executedPanel, gridBagConstraints);

        executedLabel.setText("EXECUTED");
        gridBagConstraints = new java.awt.GridBagConstraints();
        gridBagConstraints.gridx = 6;
        gridBagConstraints.gridy = 1;
        gridBagConstraints.anchor = java.awt.GridBagConstraints.LAST_LINE_START;
        gridBagConstraints.insets = new java.awt.Insets(20, 5, 10, 5);
        add(executedLabel, gridBagConstraints);
    }// </editor-fold>//GEN-END:initComponents

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JLabel activeLabel;
    private javax.swing.JPanel activePanel;
    private javax.swing.JLabel executedLabel;
    private javax.swing.JPanel executedPanel;
    private javax.swing.JLabel inactiveLabel;
    private javax.swing.JPanel inactivePanel;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel legendLabel;
    // End of variables declaration//GEN-END:variables

    private void init(COAGraph coaGraph) {
    	
    	// Initialize Graph legend and main panel's background (white)
    	initGraphLegendAndPanelBackground();

		// Create Graph visualization
    	this._coaGraph = coaGraph;
		_graph = new mxGraph();
		_parent = _graph.getDefaultParent();

		try {
			// Begin transaction
			_graph.getModel().beginUpdate();
			
			// Add all nodes
			for (COANode n: coaGraph.getAllCOANodes().values()) {
				mxCell cell = (mxCell) _graph.insertVertex(_parent, null, n.getNodeName(), 20, 20, 30, 30, getNodeDisplayStyle(n));
				
				_cell2COANodeMap.put(cell, n);
				_coaNode2Cell.put(n, cell);
			}
			
			// Add all edges
			for (COAEdge e: coaGraph.getAllCOAEdges()) {
				mxCell fromCell = _coaNode2Cell.get(e.getFromNode());
				mxCell toCell = _coaNode2Cell.get(e.getToNode());

				_graph.insertEdge(_parent, null, "", fromCell, toCell);
			}

			// Set horizontal hierarchical layout
			mxHierarchicalLayout layout = new mxHierarchicalLayout(_graph, JLabel.WEST);
			layout.execute(_parent);

		} catch (Exception e1) {
			System.out.println("Error while creating COA visualization");
			e1.printStackTrace();

		} finally {
			// End transaction
			_graph.getModel().endUpdate();
		}

		// Setup ScrollPane
		_graphComponent = new mxGraphComponent(_graph);
		jScrollPane1.setViewportView(_graphComponent);
		_graphComponent.getViewport().setBackground(Color.WHITE);

		// Disable interaction/editing of graph
		_graphComponent.setEnabled(false);

		// Add property change listener for status updates
		_coaGraph.addPropertyChangeListener(COAGraph.PROP_GRAPH_STATUS, this);
	}
    
    private void initGraphLegendAndPanelBackground() {
    	// Set legend panel sizes
    	int legendPanelSizeX = 10;
    	int legendPanelSizeY = legendPanelSizeX;
    	inactivePanel.setSize(legendPanelSizeX, legendPanelSizeY);
    	activePanel.setSize(legendPanelSizeX, legendPanelSizeY);
    	executedPanel.setSize(legendPanelSizeX, legendPanelSizeY);
    	
    	// Set legend panel colors
    	inactivePanel.setBackground(Color.GREEN);
    	activePanel.setBackground(Color.YELLOW);
    	executedPanel.setBackground(Color.RED);
    	
    	// Set main panel's background as white
    	setBackground(Color.WHITE);
    }

    private String getNodeDisplayStyle(COANode n) {
    	return "shape=image;image=" + n.getNodeStatusImagePath() + ";" + mxConstants.STYLE_VERTICAL_LABEL_POSITION + "=" + mxConstants.ALIGN_BOTTOM;
    }
    
    /** 
     * Update graph for status changes
     */
    public void updateGraphStatus() {
    	// Begin transaction
		_graph.getModel().beginUpdate();

		try {
			// Update image on all nodes
			for (COANode n: _coaGraph.getAllCOANodes().values()) {
				mxCell cell = _coaNode2Cell.get(n);
				
				cell.setStyle(getNodeDisplayStyle(n));
			}

			// Repaint graph
	    	_graphComponent.refresh();
			
		} catch (Exception e1) {
			System.out.println("Error while updating graph status");
			e1.printStackTrace();

		} finally {
			// End transaction
			_graph.getModel().endUpdate();
		}

    	_graphComponent.revalidate();
    	jScrollPane1.revalidate();
    	revalidate();
    	_graphComponent.refresh();
    	_graphComponent.repaint();
    	jScrollPane1.repaint();
    	repaint();
    }

    /**
     * propertyChange event handler
     */
	public void propertyChange(PropertyChangeEvent evt) {
		assert evt.getSource() instanceof COAGraph;
		if (COAGraph.PROP_GRAPH_STATUS.equals(evt.getPropertyName())) {
			updateGraphStatus();
		}
	}
}
